<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Algorithmic Bubble â€“ Card Flow</title>
  <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable.min.css" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, "Noto Sans KR", "Noto Sans", sans-serif;
      color: #f5f5f5;
    }
    body {
      position: relative;
      background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25), rgba(255, 0, 191, 0.25));
    }
    /* --- Common Stage Styles --- */
    .stage {
      position: absolute;
      inset: 0;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .stage.active {
      opacity: 1;
      pointer-events: auto;
    }
    .stage-desc {
      position: absolute;
      top: 50px;
      left: 32px;
      font-size: 30px;
      font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, "Noto Sans KR", sans-serif;
      font-weight: 200;
      font-variation-settings: "wght" 200;
      opacity: 0.8;
      max-width: 400px;
      line-height: 1.5;
      z-index: 10;
    }
    /* --- Stage 1: Pile --- */
    #pile-stage {
      background: transparent;
    }
    .pile-area {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .pile-card {
      position: absolute;
      width: 120px;
      height: 200px;
      background: #f0f0f0;
      border-radius: 5px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 16px;
      color: #111;
      transition: transform 0.1s ease-out, box-shadow 0.2s;
      will-change: transform;
      aspect-ratio: 9 / 16;
      overflow: hidden;
    }
    .pile-card video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
    }
    .pile-card .card-content {
      position: relative;
      z-index: 1;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .pile-card:hover {
      z-index: 100 !important;
      box-shadow: 0 20px 50px rgba(0,0,0,0.7);
    }
    .card-icon {
      font-size: 24px;
    }
    .card-title {
      font-size: 18px;
      font-weight: 700;
      line-height: 1.2;
    }
    .card-tag {
      font-size: 11px;
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    /* --- Stage 2 & 3: Grid --- */
    #grid-stage {
      background: transparent;
      color: #111;
    }
    #grid-stage .stage-desc {
      color: #111;
    }
    .grid-container {
      position: relative;
      width: 100%;
      height: 100vh;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
      grid-template-rows: repeat(3, 1fr);
      gap: 8px;
      padding: 12px;
      overflow: hidden;
      align-content: start;
    }
    .grid-cell {
      position: relative;
      background: transparent;
      border-radius: 8px;
      overflow: hidden;
      opacity: 0;
      transform: scale(0.9);
      transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
      aspect-ratio: 9 / 16;
      min-width: 0;
      min-height: 0;
    }
    .grid-cell.active {
      opacity: 1;
      transform: scale(1);
      background: #fff;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    .grid-cell.main-card {
      z-index: 10;
      background: #222;
      color: #fff;
      transform: scale(1.05);
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
    }
    .grid-cell.side-card {
      background: #fff;
      color: #111;
    }
    /* Card Content in Grid */
    .cell-content {
      width: 100%;
      height: 100%;
      padding: 16px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .like-btn {
      align-self: flex-end;
      padding: 8px 12px;
      border-radius: 20px;
      background: rgba(0,0,0,0.05);
      border: none;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
    }
    .like-btn:hover {
      background: rgba(255, 127, 152, 0.1);
      color: #ff7f98;
    }
    .like-btn.liked {
      background: #ff7f98;
      color: white;
    }
    .main-card .like-btn {
      background: rgba(255,255,255,0.1);
      color: #fff;
    }
    .main-card .like-btn.liked {
      background: #ff7f98;
      color: white;
    }
    .drag-hint {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 30px;
      font-size: 14px;
      font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, "Noto Sans KR", sans-serif;
      font-weight: 200;
      font-variation-settings: "wght" 200;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
    }
    .drag-hint.visible {
      opacity: 1;
    }
    /* --- Stage 4: Bubble --- */
    #bubble-stage {
      background: transparent;
    }
    #three-canvas {
      position: absolute;
      inset: 0;
    }
    .bubble-hint {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 16px 32px;
      border-radius: 30px;
      font-size: 16px;
      font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, "Noto Sans KR", sans-serif;
      font-weight: 200;
      font-variation-settings: "wght" 200;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 100;
      white-space: nowrap;
      backdrop-filter: blur(10px);
    }
    .bubble-hint.visible {
      opacity: 1;
      animation: twinkle 2s ease-in-out infinite;
    }
    @keyframes twinkle {
      0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 0.7; transform: translate(-50%, -50%) scale(1.05); }
    }
    .new-bubble-btn {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 127, 152, 0.9);
      color: white;
      padding: 14px 28px;
      border-radius: 30px;
      font-size: 14px;
      font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, "Noto Sans KR", sans-serif;
      font-weight: 200;
      font-variation-settings: "wght" 200;
      border: none;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s;
      backdrop-filter: blur(10px);
    }
    .new-bubble-btn:hover {
      background: rgba(255, 127, 152, 1);
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 4px 20px rgba(255, 127, 152, 0.5);
    }
    /* --- Logo --- */
    .logo {
      position: fixed;
      z-index: 1000;
      transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
      pointer-events: none;
    }
    .logo.start-screen {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      height: auto;
      opacity: 1;
      animation: float 3s ease-in-out infinite;
    }
    @keyframes float {
      0%, 100% {
        transform: translate(-50%, -50%) translateY(0px);
      }
      50% {
        transform: translate(-50%, -50%) translateY(-20px);
      }
    }
    .logo.small {
      top:30px;
      left: 30px;
      right: auto;
      transform: translate(0, 0);
      width: 120px;
      height: auto;
      opacity: 1 !important;
      animation: none;
      z-index: 6000 !important;
    }
    /* --- Start Screen --- */
    #start-screen {
      position: fixed;
      inset: 0;
      z-index: 999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 1;
      transition: opacity 0.8s ease;
      pointer-events: auto;
      background: transparent;
    }
    #start-screen .logo {
      margin-bottom: 150px;
    }
    #start-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    /* --- Start Button --- */
    @font-face {
      font-family: "CirrusCumulus";
      src: local("CirrusCumulus"), url("CirrusCumulus.woff2") format("woff2"),
           url("CirrusCumulus.woff") format("woff"),
           url("CirrusCumulus.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
    }
    .start-button {
      font-family: "CirrusCumulus", -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      font-size: 48px;
      font-weight: 300;
      color: rgba(255, 255, 255, 0.95);
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
      position: relative;
      top:140px;  
      text-decoration: none;
      letter-spacing: 0.1em;
      opacity: 0;
      animation: fadeInStart 1s ease 0.5s forwards, twinkle 2.5s ease-in-out infinite;
      transition: all 0.3s ease;
    }
    .start-button:hover {
      color: rgba(255, 255, 255, 1);
    }
    .start-button::after {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 2px;
      background: rgba(255, 255, 255, 0.9);
      transition: width 0.4s ease;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
    }
    .start-button:hover::after {
      width: 100%;
    }
    @keyframes fadeInStart {
      to {
        opacity: 1;
      }
    }
    @keyframes twinkle {
      0%, 100% {
        opacity: 0.85;
        text-shadow: 0 0 15px rgba(255, 255, 255, 0.4), 0 0 30px rgba(255, 255, 255, 0.2);
      }
      50% {
        opacity: 1;
        text-shadow: 0 0 25px rgba(255, 255, 255, 0.7), 0 0 50px rgba(255, 255, 255, 0.4);
      }
    }
    /* --- Stage Description Text (í•˜ë‹¨ ì¤‘ì•™) --- */
    .stage-desc-bottom {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      font-size: 16px;
      font-family: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, system-ui, "Noto Sans KR", sans-serif;
      font-weight: 200;
      font-variation-settings: "wght" 200;
      letter-spacing: 0.05em;
      text-align: center;
      opacity: 0;
      transition: opacity 0.8s ease;
      pointer-events: none;
      color: rgba(0, 0, 0, 0.7);
      max-width: 600px;
      padding: 0 20px;
      background-color: #AFFFEC;
    }
    .stage-desc-bottom.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
   <img src="logo.png" alt="Logo" class="logo start-screen" id="main-logo">
  <!-- START SCREEN -->
  <div id="start-screen">
   
    <button class="start-button" id="start-button">Start.</button>
  </div>
  <!-- Stage Description Text (í•˜ë‹¨ ì¤‘ì•™) -->
  <div class="stage-desc-bottom" id="stage-desc-bottom"></div>
  <!-- STAGE 1: PILE -->
  <section id="pile-stage" class="stage">

  
    <div class="pile-area" id="pile-area">
      <!-- Cards injected by JS -->
    </div>
  </section>
  <!-- STAGE 2 & 3: GRID -->
  <section id="grid-stage" class="stage">
  
   
    <div class="grid-container" id="grid-container">
      <!-- Grid cells injected by JS -->
    </div>
    <div class="drag-hint" id="drag-hint">
      ìŠ¤í¬ë¡¤ / ë“œë˜ê·¸
    </div>
  </section>
  <!-- STAGE 4: BUBBLE -->
  <section id="bubble-stage" class="stage">
    <div id="three-canvas"></div>
    <div class="stage-desc">
      ë‹¹ì‹ ì˜ ì„ íƒìœ¼ë¡œ ì™„ì„±ëœ ì•Œê³ ë¦¬ì¦˜ì˜ ì„¸ê³„ì…ë‹ˆë‹¤.<br>
      ë“œë˜ê·¸í•˜ì—¬ íƒí—˜í•˜ì„¸ìš”.
    </div>
    <div class="bubble-hint" id="bubble-hint-inside">ìŠ¤í¬ë¡¤ í•´ì„œ ë²„ë¸” ë°–ìœ¼ë¡œ ë‚˜ê°€ê¸°</div>
    <div class="bubble-hint" id="bubble-hint-outside" style="display: none;">5íšŒ ì´ìƒ í´ë¦­í•´ì„œ ë¹„ëˆ„ í„°íŠ¸ë¦¬ê¸°</div>
    <button class="new-bubble-btn" id="new-bubble-btn" style="display: none;">ë˜ ë‹¤ë¥¸ ë²„ë¸” ë§Œë“¤ê¸°</button>
  </section>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    // --- DATA ---
    const TOPICS = [
      { id: 'music', label: 'Music', icon: 'ğŸµ', sub: ['Techno', 'K-Pop', 'Jazz', 'Rock'] },
      { id: 'art', label: 'Art', icon: 'ğŸ¨', sub: ['Digital', 'Classic', 'NFT', 'Sketch'] },
      { id: 'travel', label: 'Travel', icon: 'âœˆï¸', sub: ['Asia', 'Europe', 'Beach', 'City'] },
      { id: 'food', label: 'Food', icon: 'ğŸ”', sub: ['Korean', 'Italian', 'Dessert', 'Vegan'] },
      { id: 'tech', label: 'Tech', icon: 'ğŸ’»', sub: ['AI', 'Coding', 'Gadgets', 'Future'] },
      { id: 'fashion', label: 'Fashion', icon: 'ğŸ‘—', sub: ['Street', 'Luxury', 'Vintage', 'Casual'] },
      { id: 'pet', label: 'Pet', icon: 'ğŸ¶', sub: ['Dog', 'Cat', 'Bird', 'Fish'] },
      { id: 'game', label: 'Game', icon: 'ğŸ®', sub: ['FPS', 'RPG', 'Indie', 'Retro'] },
    ];
    // --- STATE ---
    const state = {
      selectedTopic: null,
      likes: 0,
      isGridFull: false,
      bubbleInited: false
    };
    // --- ELEMENTS ---
    const pileArea = document.getElementById('pile-area');
    const gridContainer = document.getElementById('grid-container');
    const dragHint = document.getElementById('drag-hint');
    const startScreen = document.getElementById('start-screen');
    const startButton = document.getElementById('start-button');
    const mainLogo = document.getElementById('main-logo');
    const stageDescBottom = document.getElementById('stage-desc-bottom');
    const stages = {
      pile: document.getElementById('pile-stage'),
      grid: document.getElementById('grid-stage'),
      bubble: document.getElementById('bubble-stage')
    };
    
    // --- START SCREEN LOGIC ---
    function initStartScreen() {
      // Start ë²„íŠ¼ í´ë¦­ ì‹œ ì¹´ë“œ ì„ íƒ í™”ë©´ìœ¼ë¡œ ì „í™˜
      startButton.addEventListener('click', (e) => {
        e.stopPropagation();
        goToPileStage();
      });
      
      // ì‹œì‘ í™”ë©´ í´ë¦­ ì‹œì—ë„ ì „í™˜ (Start ë²„íŠ¼ ì œì™¸)
      startScreen.addEventListener('click', (e) => {
        if (e.target !== startButton && !startButton.contains(e.target)) {
          goToPileStage();
        }
      });
    }
    
    function goToPileStage() {
      // ì‹œì‘ í™”ë©´ ìˆ¨ê¸°ê¸°
      startScreen.classList.add('hidden');
      
      // ë¡œê³ ë¥¼ ì¢Œì¸¡ ìƒë‹¨ìœ¼ë¡œ ì´ë™ (ê³ ì •)
      mainLogo.classList.remove('start-screen');
      mainLogo.classList.add('small');
      
      // ì„¤ëª… í…ìŠ¤íŠ¸ í‘œì‹œ
      setTimeout(() => {
        stageDescBottom.textContent = 'ë§ˆìš°ìŠ¤ë¥¼ ì›€ì§ì—¬ ì¹´ë“œë¥¼ í—¤ì¹˜ê³ , ë§ˆìŒì— ë“œëŠ” ì¹´ë“œ í•˜ë‚˜ë¥¼ ì„ íƒí•´ë³´ì„¸ìš”.';
        stageDescBottom.classList.add('visible');
      }, 400);
      
      // ì¹´ë“œ ì„ íƒ í™”ë©´ í™œì„±í™”
      setTimeout(() => {
        stages.pile.classList.add('active');
        initPile();
      }, 400);
    }
    
    // ìŠ¤í…Œì´ì§€ë³„ ì„¤ëª… í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateStageDesc(text) {
      stageDescBottom.textContent = text;
      if (!stageDescBottom.classList.contains('visible')) {
        stageDescBottom.classList.add('visible');
      }
    }
    // --- STAGE 1: PILE LOGIC ---
    // ìƒ˜í”Œ ë¹„ë””ì˜¤ URL ë°°ì—´ (ë§¨ ì²˜ìŒ ì¹´ë“œìš©)
    const pileVideoUrls = [
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/SubaruOutbackOnStreetAndDirt.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4'
    ];
    
    function initPile() {
      // Generate random cards
      for (let i = 0; i < 15; i++) {
        const topic = TOPICS[i % TOPICS.length];
        const card = document.createElement('div');
        card.className = 'pile-card';
        const videoUrl = pileVideoUrls[i % pileVideoUrls.length];
        card.innerHTML = `
          <video autoplay loop muted playsinline>
            <source src="${videoUrl}" type="video/mp4">
          </video>
          <div class="card-content">
            <div class="card-icon">${topic.icon}</div>
            <div class="card-title" style="color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.7);">${topic.label}</div>
            <div class="card-tag" style="color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.7);">#${topic.sub[0]}</div>
          </div>
        `;
        
        // ë¹„ë””ì˜¤ ì¬ìƒ
        const video = card.querySelector('video');
        if (video) {
          video.play().catch(e => console.log('Video autoplay prevented:', e));
        }
        
        // Random position near center
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 100;
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;
        const rot = (Math.random() - 0.5) * 60;
        card.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg)`;
        card.dataset.x = x;
        card.dataset.y = y;
        card.dataset.rot = rot;
        card.dataset.topic = JSON.stringify(topic);
        // Click Event
        card.addEventListener('click', (e) => {
          e.stopPropagation();
          selectCard(topic, card);
        });
        pileArea.appendChild(card);
      }
      // Physics Effect - ì‹¤ì œ ë¬¼ë¦¬ ê¸°ë°˜ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ í©ì–´ì§€ê¸°
      const cards = document.querySelectorAll('.pile-card');
      const cardPhysics = {};
      let hasSpread = false; // ì¹´ë“œê°€ í¼ì³ì¡ŒëŠ”ì§€ ì¶”ì 
      let initialSpreadTime = 0;
      
      // ê° ì¹´ë“œì— ë¬¼ë¦¬ ì†ì„± ì´ˆê¸°í™”
      cards.forEach((card, i) => {
        cardPhysics[i] = {
          vx: 0, // x ì†ë„
          vy: 0, // y ì†ë„
          baseX: parseFloat(card.dataset.x),
          baseY: parseFloat(card.dataset.y),
          spreadX: 0, // í¼ì³ì§„ ìœ„ì¹˜ X
          spreadY: 0, // í¼ì³ì§„ ìœ„ì¹˜ Y
          currentX: parseFloat(card.dataset.x),
          currentY: parseFloat(card.dataset.y),
          rot: parseFloat(card.dataset.rot)
        };
      });
      
      // ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì¶”ì 
      let mouseX = window.innerWidth / 2;
      let mouseY = window.innerHeight / 2;
      let isMouseInArea = false;
      
      // ì²˜ìŒ í˜¸ë²„ ì‹œ ì¹´ë“œë“¤ì„ íƒ€ì›í˜•ìœ¼ë¡œ í¼ì¹˜ê¸° (ìœ„ì•„ë˜ ê°„ê²© ì¤„ì´ê¸°)
      pileArea.addEventListener('mouseenter', () => {
        isMouseInArea = true;
        if (!hasSpread) {
          // ì²˜ìŒ í˜¸ë²„ ì‹œ ì¹´ë“œë“¤ì„ íƒ€ì›í˜•ìœ¼ë¡œ í¼ì¹˜ê¸°
          const spreadRadiusX = 200; // ê°€ë¡œ ë°˜ê²½
          const spreadRadiusY = 120; // ì„¸ë¡œ ë°˜ê²½ (ìœ„ì•„ë˜ ê°„ê²© ì¤„ì„)
          cards.forEach((card, i) => {
            const physics = cardPhysics[i];
            const angle = (i / cards.length) * Math.PI * 2;
            physics.spreadX = Math.cos(angle) * spreadRadiusX;
            physics.spreadY = Math.sin(angle) * spreadRadiusY; // Yì¶• ë°˜ê²½ì„ ì¤„ì—¬ì„œ ìœ„ì•„ë˜ ê°„ê²© ì¶•ì†Œ
            hasSpread = true;
            initialSpreadTime = Date.now();
          });
        }
      });
      
      pileArea.addEventListener('mouseleave', () => {
        isMouseInArea = false;
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!stages.pile.classList.contains('active')) return;
        mouseX = e.clientX;
        mouseY = e.clientY;
      });
      
      // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ë£¨í”„
      function physicsUpdate() {
        if (!stages.pile.classList.contains('active')) {
          requestAnimationFrame(physicsUpdate);
          return;
        }
        
        const timeSinceSpread = Date.now() - initialSpreadTime;
        const spreadDuration = 1000; // í¼ì³ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„
        
        cards.forEach((card, i) => {
          const physics = cardPhysics[i];
          const rect = card.getBoundingClientRect();
          const cardCx = rect.left + rect.width / 2;
          const cardCy = rect.top + rect.height / 2;
          
          // ì²˜ìŒ í˜¸ë²„ ì‹œ í¼ì³ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜
          if (hasSpread && timeSinceSpread < spreadDuration) {
            const progress = Math.min(timeSinceSpread / spreadDuration, 1);
            const easeProgress = 1 - Math.pow(1 - progress, 3); // ease-out
            const targetX = physics.baseX + (physics.spreadX - physics.baseX) * easeProgress;
            const targetY = physics.baseY + (physics.spreadY - physics.baseY) * easeProgress;
            
            physics.currentX = targetX;
            physics.currentY = targetY;
          } else if (hasSpread) {
            // í¼ì³ì§„ í›„ì—ëŠ” í¼ì³ì§„ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ
            const targetX = physics.baseX + physics.spreadX;
            const targetY = physics.baseY + physics.spreadY;
            
            // í¼ì³ì§„ ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™
            const restoreStrength = 0.15;
            physics.vx += (targetX - physics.currentX) * restoreStrength;
            physics.vy += (targetY - physics.currentY) * restoreStrength;
          }
          
          // ë§ˆìš°ìŠ¤ ë°˜ë°œë ¥ (í¼ì³ì§„ í›„ì—ë§Œ ì ìš©)
          if (hasSpread && isMouseInArea) {
            const dx = mouseX - cardCx;
            const dy = mouseY - cardCy;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDist = 130; // ë°˜ì‘ ê±°ë¦¬
            
            if (dist < maxDist && dist > 0) {
              // ë°˜ë°œë ¥ ê³„ì‚° (ë§¤ìš° ì•½í•˜ê²Œ - ë„ë§ê°€ëŠ” ì„±í–¥ ìµœì†Œí™”)
              const force = (maxDist - dist) / maxDist;
              const repulsionStrength = 1.5; // í˜ì˜ ê°•ë„ë¥¼ í¬ê²Œ ì¤„ì„
              const fx = -(dx / dist) * force * repulsionStrength;
              const fy = -(dy / dist) * force * repulsionStrength;
              
              // ê°€ì†ë„ ì ìš©
              physics.vx += fx;
              physics.vy += fy;
            }
          }
          
          // ë§ˆì°°ë ¥ ì ìš© (ì†ë„ ê°ì†Œ - ë” ë¹ ë¥´ê²Œ ì •ì§€)
          const friction = 0.55;
          physics.vx *= friction;
          physics.vy *= friction;
          
          // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
          physics.currentX += physics.vx;
          physics.currentY += physics.vy;
          
          // ë³€í™˜ ì ìš©
          card.style.transform = `translate(${physics.currentX}px, ${physics.currentY}px) rotate(${physics.rot}deg)`;
        });
        
        requestAnimationFrame(physicsUpdate);
      }
      
      physicsUpdate();
    }
    // --- STAGE 2: TRANSITION TO GRID ---
    function selectCard(topic, clickedCard = null) {
      state.selectedTopic = topic;
      
      // í´ë¦­í•œ ì¹´ë“œê°€ ìˆìœ¼ë©´ í™”ë©´ ê°€ìš´ë°ë¡œ ì´ë™
      if (clickedCard) {
        const card = clickedCard;
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const rect = card.getBoundingClientRect();
        const currentX = rect.left + rect.width / 2;
        const currentY = rect.top + rect.height / 2;
        const targetX = centerX - currentX;
        const targetY = centerY - currentY;
        
        card.style.transition = 'transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), z-index 0.6s';
        card.style.zIndex = '1000';
        
        const baseX = parseFloat(card.dataset.x);
        const baseY = parseFloat(card.dataset.y);
        const rot = parseFloat(card.dataset.rot);
        
        card.style.transform = `translate(${baseX + targetX}px, ${baseY + targetY}px) rotate(0deg) scale(1.2)`;
        
        setTimeout(() => {
          // Switch Stage
          stages.pile.classList.remove('active');
          stages.grid.classList.add('active');
          updateStageDesc('ì„ íƒí•œ ì½˜í…ì¸ ì™€ ì—°ê´€ëœ íë¦„ì´ ì´ì–´ì§‘ë‹ˆë‹¤. ì¢‹ì•„ìš”ë¥¼ ëˆŒëŸ¬ ì•Œê³ ë¦¬ì¦˜ì„ í™•ì¥í•˜ì„¸ìš”.');
          initGrid(topic);
        }, 600);
      } else {
        // Switch Stage
        stages.pile.classList.remove('active');
        stages.grid.classList.add('active');
        updateStageDesc('ì„ íƒí•œ ì½˜í…ì¸ ì™€ ì—°ê´€ëœ íë¦„ì´ ì´ì–´ì§‘ë‹ˆë‹¤. ì¢‹ì•„ìš”ë¥¼ ëˆŒëŸ¬ ì•Œê³ ë¦¬ì¦˜ì„ í™•ì¥í•˜ì„¸ìš”.');
        initGrid(topic);
      }
    }
    // --- STAGE 3: GRID EXPANSION ---
    function initGrid(topic) {
      gridContainer.innerHTML = '';
      
      // 3í–‰ìœ¼ë¡œ ê³ ì •í•˜ê³  ì¹´ë“œ í¬ê¸° ì¡°ì •
      const rows = 3; // 3í–‰ ê³ ì •
      const gap = 8;
      const padding = 12;
      const availableWidth = window.innerWidth - padding * 2;
      const availableHeight = window.innerHeight - padding * 2;
      
      // 3í–‰ì— ë§ì¶° ì¹´ë“œ ë†’ì´ ê³„ì‚° (ê²¹ì¹˜ì§€ ì•Šê²Œ)
      const cardHeight = (availableHeight - (gap * (rows - 1))) / rows;
      const cardWidth = cardHeight * (9 / 16); // ë¦´ìŠ¤ì¹´ë“œ ë¹„ìœ¨ ìœ ì§€
      
      // ì—´ ìˆ˜ ê³„ì‚°
      const cols = Math.max(3, Math.floor(availableWidth / (cardWidth + gap)));
      const totalCells = cols * rows;
      
      // ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ ì¡°ì •
      gridContainer.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
      gridContainer.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
      
      const cells = [];
      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement('div');
        cell.className = 'grid-cell';
        cell.dataset.index = i;
        gridContainer.appendChild(cell);
        cells.push(cell);
      }
      
      // Setup Main Card (Center-ish)
      const centerIdx = Math.floor(totalCells / 2);
      setupCell(cells[centerIdx], topic, true);
      cells[centerIdx].classList.add('main-card', 'active');
      
      // Setup Side Cards (Immediate Context)
      setTimeout(() => {
        if (centerIdx - 1 >= 0) {
          setupCell(cells[centerIdx - 1], { ...topic, label: topic.sub[0] }, false);
          cells[centerIdx - 1].classList.add('side-card', 'active');
        }
      }, 300);
      setTimeout(() => {
        if (centerIdx + 1 < totalCells) {
          setupCell(cells[centerIdx + 1], { ...topic, label: topic.sub[1] }, false);
          cells[centerIdx + 1].classList.add('side-card', 'active');
        }
      }, 600);
    }
    // ìƒ˜í”Œ ë¹„ë””ì˜¤ URL ë°°ì—´ (ê·¸ë¦¬ë“œ ì¹´ë“œìš©)
    const gridVideoUrls = [
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/SubaruOutbackOnStreetAndDirt.mp4',
      'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4'
    ];
    
    function setupCell(element, data, isMain) {
      const cellIndex = parseInt(element.dataset.index) || 0;
      const videoUrl = gridVideoUrls[cellIndex % gridVideoUrls.length];
      
      element.innerHTML = `
        <div class="cell-content">
          <video class="card-video" autoplay loop muted playsinline style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 8px; pointer-events: none;">
            <source src="${videoUrl}" type="video/mp4">
          </video>
          <div style="position: relative; z-index: 2; height: 100%; display: flex; flex-direction: column; justify-content: space-between; padding: 16px; pointer-events: auto;">
            <div class="card-title" style="font-size: ${isMain ? '24px' : '16px'}; color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">${data.label}</div>
            <button class="like-btn" style="background: rgba(255,255,255,0.9); pointer-events: auto; z-index: 3;">
              <span>â™¥</span> Like
            </button>
          </div>
        </div>
      `;
      
      // ë¹„ë””ì˜¤ ì¬ìƒ
      const video = element.querySelector('.card-video');
      if (video) {
        video.play().catch(e => console.log('Video autoplay prevented:', e));
      }
      
      // ì¹´ë“œ ì „ì²´ í´ë¦­ ì´ë²¤íŠ¸ (ì•„ë¬´ ê³³ì´ë‚˜ í´ë¦­í•´ë„ ì¹´ë“œ ìˆ˜ ì¦ê°€)
      element.style.cursor = 'pointer';
      element.addEventListener('click', (e) => {
        e.stopPropagation();
        const btn = element.querySelector('.like-btn');
        if (btn && !btn.classList.contains('liked')) {
          btn.classList.add('liked');
          expandGrid();
        }
      });
      
      // ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ (ì¤‘ë³µ ë°©ì§€)
      const btn = element.querySelector('.like-btn');
      if (btn) {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (!btn.classList.contains('liked')) {
            btn.classList.add('liked');
            expandGrid();
          }
        });
      }
    }
    function expandGrid() {
      state.likes++;
      
      // Reveal more cells based on likes
      const cells = Array.from(document.querySelectorAll('.grid-cell:not(.active)'));
      
      if (cells.length === 0) return;
      // Reveal 3 random cells per like
      const toReveal = cells.sort(() => 0.5 - Math.random()).slice(0, 3);
      
      toReveal.forEach((cell, i) => {
        setTimeout(() => {
          const subTopic = state.selectedTopic.sub[Math.floor(Math.random() * state.selectedTopic.sub.length)];
          setupCell(cell, { label: subTopic }, false);
          cell.classList.add('side-card', 'active');
        }, i * 100);
      });
      // Check if full
      const remaining = document.querySelectorAll('.grid-cell:not(.active)').length;
      if (remaining <= 3 && !state.isGridFull) {
        state.isGridFull = true;
        // ìë™ìœ¼ë¡œ ë²„ë¸” ìŠ¤í…Œì´ì§€ë¡œ ì „í™˜
        setTimeout(() => {
          goToBubbleStage();
        }, 500);
      }
    }
    let grid3DState = {
      is3DMode: false,
      scrollProgress: 0,
      isTransitioning: false
    };
    
    function enableDragToBubble() {
      let isDragging = false;
      let startX = 0;
      let startY = 0;
      let dragDistance = 0;
      let hasStarted3D = false;
      
      // ë“œë˜ê·¸ ì‹œì‘
      gridContainer.addEventListener('mousedown', (e) => {
        if (grid3DState.isTransitioning) return;
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        dragDistance = 0;
        hasStarted3D = false;
        gridContainer.style.cursor = 'grabbing';
      });
      
      // ë“œë˜ê·¸ ì¤‘
      gridContainer.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        dragDistance = Math.sqrt(dx * dx + dy * dy);
        
        // ë“œë˜ê·¸ê°€ ì‹œì‘ë˜ë©´ ë°”ë¡œ 3D ëª¨ë“œë¡œ ì „í™˜
        if (dragDistance > 10 && !hasStarted3D) {
          hasStarted3D = true;
          grid3DState.is3DMode = true;
          grid3DState.isTransitioning = true;
          
          // ê·¸ë¦¬ë“œë¥¼ êµ¬ í˜•íƒœë¡œ ë³€í˜• (ê´‘ê° íš¨ê³¼)
          const cells = Array.from(document.querySelectorAll('.grid-cell.active'));
          const radius = 8;
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          
          cells.forEach((cell, i) => {
            const rect = cell.getBoundingClientRect();
            const cellX = rect.left + rect.width / 2;
            const cellY = rect.top + rect.height / 2;
            
            // êµ¬ í˜•íƒœë¡œ ë³€í˜•
            const phi = Math.acos(-1 + (2 * i) / cells.length);
            const theta = Math.sqrt(cells.length * Math.PI) * phi;
            
            const x = Math.sin(phi) * Math.cos(theta) * radius;
            const y = Math.sin(phi) * Math.sin(theta) * radius;
            const z = Math.cos(phi) * radius;
            
            const translateX = (x / radius) * 200;
            const translateY = (y / radius) * 200;
            const translateZ = (z / radius) * 200;
            
            cell.style.transition = 'transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)';
            cell.style.transform = `translate3d(${translateX}px, ${translateY}px, ${translateZ}px) scale(0.9)`;
            cell.style.transformStyle = 'preserve-3d';
          });
          
          // ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆì— perspective ì ìš©
          gridContainer.style.perspective = '2000px';
          gridContainer.style.transformStyle = 'preserve-3d';
          
          setTimeout(() => {
            grid3DState.isTransitioning = false;
            dragHint.textContent = 'ê³„ì† ë“œë˜ê·¸í•˜ì—¬ 3D ê³µê°„ìœ¼ë¡œ ë“¤ì–´ê°€ì„¸ìš”';
          }, 800);
        }
        
        // ë“œë˜ê·¸ ì§„í–‰ë„ì— ë”°ë¼ 3Dë¡œ ì „í™˜
        if (hasStarted3D && !grid3DState.isTransitioning) {
          const maxDragDistance = 300;
          const progress = Math.min(dragDistance / maxDragDistance, 1);
          grid3DState.scrollProgress = progress;
          
          const cells = Array.from(document.querySelectorAll('.grid-cell.active'));
          const radius = 8;
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          
          cells.forEach((cell, i) => {
            const phi = Math.acos(-1 + (2 * i) / cells.length);
            const theta = Math.sqrt(cells.length * Math.PI) * phi;
            
            // ëª©í‘œ êµ¬ ì¢Œí‘œ
            const targetX = Math.sin(phi) * Math.cos(theta) * radius;
            const targetY = Math.sin(phi) * Math.sin(theta) * radius;
            const targetZ = Math.cos(phi) * radius;
            
            // í˜„ì¬ 2D ìœ„ì¹˜ì—ì„œ 3D êµ¬ ìœ„ì¹˜ë¡œ ë³´ê°„
            const rect = cell.getBoundingClientRect();
            const currentX = (rect.left + rect.width / 2 - centerX) / 200 * radius;
            const currentY = (rect.top + rect.height / 2 - centerY) / 200 * radius;
            
            const finalX = currentX * (1 - progress) + targetX * progress;
            const finalY = currentY * (1 - progress) + targetY * progress;
            const finalZ = targetZ * progress;
            
            // 3D ë³€í™˜ ì ìš©
            const scale = 0.9 + progress * 0.1;
            const translateX = finalX * 200 / radius;
            const translateY = finalY * 200 / radius;
            const translateZ = finalZ * 200 / radius;
            
            // ì¹´ë“œê°€ ì¤‘ì‹¬ì„ í–¥í•˜ë„ë¡ íšŒì „ ê³„ì‚°
            const distance = Math.sqrt(finalX * finalX + finalY * finalY + finalZ * finalZ);
            if (distance > 0.1 && progress > 0.2) {
              const rotY = Math.atan2(finalX, finalZ) * 180 / Math.PI;
              const rotX = -Math.asin(finalY / distance) * 180 / Math.PI;
              
              cell.style.transition = 'transform 0.1s ease-out';
              cell.style.transform = `translate3d(${translateX}px, ${translateY}px, ${translateZ}px) scale(${scale}) rotateY(${rotY * progress}deg) rotateX(${rotX * progress}deg)`;
            } else {
              cell.style.transition = 'transform 0.1s ease-out';
              cell.style.transform = `translate3d(${translateX}px, ${translateY}px, ${translateZ}px) scale(${scale})`;
            }
          });
          
          // ê·¸ë¦¬ë“œ ì»¨í…Œì´ë„ˆì—ë„ perspective íš¨ê³¼ ì ìš©
          const perspectiveAmount = 2000 + progress * 1000;
          gridContainer.style.perspective = `${perspectiveAmount}px`;
          
          // ë“œë˜ê·¸ê°€ ì¶©ë¶„íˆ ì§„í–‰ë˜ë©´ ë²„ë¸” ìŠ¤í…Œì´ì§€ë¡œ ì „í™˜
          if (progress >= 0.85) {
            goToBubbleStage();
            isDragging = false;
          }
        }
      });
      
      // ë“œë˜ê·¸ ì¢…ë£Œ
      window.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          gridContainer.style.cursor = 'grab';
          
          // ë“œë˜ê·¸ê°€ ì¶©ë¶„í•˜ì§€ ì•Šìœ¼ë©´ ë˜ëŒë¦¬ê¸°
          if (grid3DState.scrollProgress < 0.5 && hasStarted3D) {
            const cells = Array.from(document.querySelectorAll('.grid-cell.active'));
            cells.forEach((cell) => {
              cell.style.transition = 'transform 0.5s ease-out';
              cell.style.transform = '';
            });
            grid3DState.is3DMode = false;
            grid3DState.scrollProgress = 0;
            hasStarted3D = false;
          }
        }
      });
      
      // í„°ì¹˜ ì´ë²¤íŠ¸ ì§€ì›
      gridContainer.addEventListener('touchstart', (e) => {
        if (grid3DState.isTransitioning) return;
        isDragging = true;
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        dragDistance = 0;
        hasStarted3D = false;
      });
      
      gridContainer.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        const dx = e.touches[0].clientX - startX;
        const dy = e.touches[0].clientY - startY;
        dragDistance = Math.sqrt(dx * dx + dy * dy);
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ì™€ ë™ì¼í•œ ë¡œì§ ì ìš©
        if (dragDistance > 10 && !hasStarted3D) {
          hasStarted3D = true;
          grid3DState.is3DMode = true;
          grid3DState.isTransitioning = true;
          
          const cells = Array.from(document.querySelectorAll('.grid-cell.active'));
          const radius = 8;
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          
          cells.forEach((cell, i) => {
            const phi = Math.acos(-1 + (2 * i) / cells.length);
            const theta = Math.sqrt(cells.length * Math.PI) * phi;
            
            const x = Math.sin(phi) * Math.cos(theta) * radius;
            const y = Math.sin(phi) * Math.sin(theta) * radius;
            const z = Math.cos(phi) * radius;
            
            const translateX = (x / radius) * 200;
            const translateY = (y / radius) * 200;
            const translateZ = (z / radius) * 200;
            
            cell.style.transition = 'transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1)';
            cell.style.transform = `translate3d(${translateX}px, ${translateY}px, ${translateZ}px) scale(0.9)`;
            cell.style.transformStyle = 'preserve-3d';
          });
          
          gridContainer.style.perspective = '2000px';
          gridContainer.style.transformStyle = 'preserve-3d';
          
          setTimeout(() => {
            grid3DState.isTransitioning = false;
          }, 800);
        }
        
        if (hasStarted3D && !grid3DState.isTransitioning) {
          const maxDragDistance = 300;
          const progress = Math.min(dragDistance / maxDragDistance, 1);
          grid3DState.scrollProgress = progress;
          
          const cells = Array.from(document.querySelectorAll('.grid-cell.active'));
          const radius = 8;
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          
          cells.forEach((cell, i) => {
            const phi = Math.acos(-1 + (2 * i) / cells.length);
            const theta = Math.sqrt(cells.length * Math.PI) * phi;
            
            const targetX = Math.sin(phi) * Math.cos(theta) * radius;
            const targetY = Math.sin(phi) * Math.sin(theta) * radius;
            const targetZ = Math.cos(phi) * radius;
            
            const rect = cell.getBoundingClientRect();
            const currentX = (rect.left + rect.width / 2 - centerX) / 200 * radius;
            const currentY = (rect.top + rect.height / 2 - centerY) / 200 * radius;
            
            const finalX = currentX * (1 - progress) + targetX * progress;
            const finalY = currentY * (1 - progress) + targetY * progress;
            const finalZ = targetZ * progress;
            
            const scale = 0.9 + progress * 0.1;
            const translateX = finalX * 200 / radius;
            const translateY = finalY * 200 / radius;
            const translateZ = finalZ * 200 / radius;
            
            const distance = Math.sqrt(finalX * finalX + finalY * finalY + finalZ * finalZ);
            if (distance > 0.1 && progress > 0.2) {
              const rotY = Math.atan2(finalX, finalZ) * 180 / Math.PI;
              const rotX = -Math.asin(finalY / distance) * 180 / Math.PI;
              
              cell.style.transition = 'transform 0.1s ease-out';
              cell.style.transform = `translate3d(${translateX}px, ${translateY}px, ${translateZ}px) scale(${scale}) rotateY(${rotY * progress}deg) rotateX(${rotX * progress}deg)`;
            } else {
              cell.style.transition = 'transform 0.1s ease-out';
              cell.style.transform = `translate3d(${translateX}px, ${translateY}px, ${translateZ}px) scale(${scale})`;
            }
          });
          
          const perspectiveAmount = 2000 + progress * 1000;
          gridContainer.style.perspective = `${perspectiveAmount}px`;
          
          if (progress >= 0.85) {
            goToBubbleStage();
            isDragging = false;
          }
        }
      });
      
      window.addEventListener('touchend', () => {
        if (isDragging) {
          isDragging = false;
          
          if (grid3DState.scrollProgress < 0.5 && hasStarted3D) {
            const cells = Array.from(document.querySelectorAll('.grid-cell.active'));
            cells.forEach((cell) => {
              cell.style.transition = 'transform 0.5s ease-out';
              cell.style.transform = '';
            });
            grid3DState.is3DMode = false;
            grid3DState.scrollProgress = 0;
            hasStarted3D = false;
          }
        }
      });
    }
    function goToBubbleStage() {
      // ê·¸ë¦¬ë“œì˜ ì¹´ë“œë“¤ì„ ìˆ˜ì§‘í•˜ì—¬ êµ¬ë¡œ ë³€í™˜
      const gridCards = Array.from(document.querySelectorAll('.grid-cell.active'));
      const cardData = gridCards.map((cell, index) => {
        const rect = cell.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const title = cell.querySelector('.card-title')?.textContent || '';
        const isLiked = cell.querySelector('.like-btn')?.classList.contains('liked') || false;
        return {
          x: (centerX - window.innerWidth / 2) / window.innerWidth * 20, // 3D ê³µê°„ìœ¼ë¡œ ìŠ¤ì¼€ì¼
          y: -(centerY - window.innerHeight / 2) / window.innerHeight * 20, // Yì¶• ë°˜ì „
          z: 0,
          title,
          isLiked,
          index
        };
      });
      
      // ê·¸ë¦¬ë“œ í˜ì´ë“œì•„ì›ƒ
      stages.grid.style.transition = 'opacity 0.8s ease';
      stages.grid.style.opacity = '0';
      
      setTimeout(() => {
        stages.grid.classList.remove('active');
        stages.bubble.classList.add('active');
        updateStageDesc('ë‹¹ì‹ ì˜ ì„ íƒìœ¼ë¡œ ì™„ì„±ëœ ì•Œê³ ë¦¬ì¦˜ì˜ ì„¸ê³„ì…ë‹ˆë‹¤. ë“œë˜ê·¸í•˜ì—¬ íƒí—˜í•˜ì„¸ìš”.');
        
        if (!state.bubbleInited) {
          initThreeJS(cardData);
          state.bubbleInited = true;
        }
      }, 400);
    }
    // --- STAGE 4: THREE.JS BUBBLE ---
    let bubbleState = {
      cameraDistance: 0.1,
      isOutside: false,
      clickCount: 0,
      lastClickTime: 0,
      isExploding: false
    };
    
    function initThreeJS(cardData = []) {
      const container = document.getElementById('three-canvas');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
      
      // Cards on Sphere - ë¦´ìŠ¤ì¹´ë“œ í˜•íƒœë¡œ í†µì¼
      const group = new THREE.Group();
      scene.add(group);
      
      // ë²„ë¸” ì¹´ë“œ ìˆ˜ë¥¼ ëŒ€í­ ì¦ê°€ - ë²„ë¸” ë°–ì—ì„œ ë³´ë©´ ì•ˆì´ ì•ˆ ë³´ì¼ ì •ë„ë¡œ
      // ìµœì†Œ 250ê°œë¡œ ì„¤ì •í•˜ì—¬ êµ¬ê°€ ì™„ì „íˆ ì±„ì›Œì§€ë„ë¡
      const count = Math.max(250, cardData.length * 3);
      const radius = 8;
      const cardAspect = 9 / 16; // ë¦´ìŠ¤ì¹´ë“œ ë¹„ìœ¨
      const cardHeight = 2.2;
      const cardWidth = cardHeight * cardAspect;
      
      // ë¹„ë””ì˜¤ í…ìŠ¤ì²˜ ìƒì„± í•¨ìˆ˜
      function createVideoTexture(videoUrl) {
        const video = document.createElement('video');
        video.src = videoUrl;
        video.crossOrigin = 'anonymous';
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        video.play();
        
        const texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        return texture;
      }
      
      // ìƒ˜í”Œ ë¹„ë””ì˜¤ URL ë°°ì—´ (ì‹¤ì œ ì‚¬ìš© ì‹œ ì›í•˜ëŠ” ë¹„ë””ì˜¤ URLë¡œ êµì²´)
      const videoUrls = [
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/Sintel.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/SubaruOutbackOnStreetAndDirt.mp4',
        'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4'
      ];
      
      const cards = [];
      for (let i = 0; i < count; i++) {
        const phi = Math.acos(-1 + (2 * i) / count);
        const theta = Math.sqrt(count * Math.PI) * phi;
        const geometry = new THREE.PlaneGeometry(cardWidth, cardHeight);
        
        // ë¹„ë””ì˜¤ í…ìŠ¤ì²˜ ì ìš© (ëª¨ë“  ì¹´ë“œì— ì ìš©)
        let material;
        try {
          const videoTexture = createVideoTexture(videoUrls[i % videoUrls.length]);
          material = new THREE.MeshBasicMaterial({ 
            map: videoTexture,
            side: THREE.DoubleSide
          });
        } catch (e) {
          // ë¹„ë””ì˜¤ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ìƒ‰ìƒìœ¼ë¡œ ëŒ€ì²´
          console.log('Video load failed, using color:', e);
          material = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            side: THREE.DoubleSide
          });
          material.color.setHSL(Math.random(), 0.7, 0.5);
        }
        
        const card = new THREE.Mesh(geometry, material);
        
        // ê·¸ë¦¬ë“œì—ì„œ ì „í™˜ëœ ê²½ìš° ì´ˆê¸° ìœ„ì¹˜ë¥¼ ê·¸ë¦¬ë“œ ìœ„ì¹˜ë¡œ ì„¤ì •
        if (cardData && cardData[i % cardData.length]) {
          const dataIndex = i % cardData.length;
          card.position.set(
            cardData[dataIndex].x,
            cardData[dataIndex].y,
            cardData[dataIndex].z || 0
          );
          card.userData.targetPosition = new THREE.Vector3();
          card.userData.targetPosition.setFromSphericalCoords(radius, phi, theta);
          card.userData.isTransitioning = true;
          card.userData.transitionProgress = 0;
        } else {
          const pos = new THREE.Vector3();
          pos.setFromSphericalCoords(radius, phi, theta);
          card.position.copy(pos);
          card.userData.targetPosition = pos.clone();
          card.userData.isTransitioning = false;
        }
        
        card.lookAt(0, 0, 0);
        
        // Store original position and rotation
        card.userData.originalPosition = card.userData.targetPosition.clone();
        card.userData.originalRotation = card.rotation.clone();
        card.userData.velocity = new THREE.Vector3(0, 0, 0);
        
        group.add(card);
        cards.push(card);
      }
      
      camera.position.z = 0.1; // Inside the sphere initially
      
      // ì•ˆë‚´ ë¬¸êµ¬ ìš”ì†Œ
      const hintInside = document.getElementById('bubble-hint-inside');
      const hintOutside = document.getElementById('bubble-hint-outside');
      const newBubbleBtn = document.getElementById('new-bubble-btn');
      
      // ì²˜ìŒì—ëŠ” ì•ˆìª½ ì•ˆë‚´ ë¬¸êµ¬ í‘œì‹œ
      setTimeout(() => {
        if (hintInside) hintInside.classList.add('visible');
      }, 1000);
      
      // Interaction
      let isDragging = false;
      let prevX = 0;
      let prevY = 0;
      let shakeIntensity = 0;
      
      container.addEventListener('mousedown', e => {
        isDragging = true;
        prevX = e.clientX;
        prevY = e.clientY;
      });
      
      window.addEventListener('mouseup', () => isDragging = false);
      
      container.addEventListener('mousemove', e => {
        if (!isDragging || bubbleState.isExploding) return;
        const dx = e.clientX - prevX;
        const dy = e.clientY - prevY;
        group.rotation.y += dx * 0.005;
        group.rotation.x += dy * 0.005;
        prevX = e.clientX;
        prevY = e.clientY;
      });
      
      // ìŠ¤í¬ë¡¤ì•„ì›ƒìœ¼ë¡œ êµ¬ ë°”ê¹¥ìœ¼ë¡œ ë‚˜ê°€ê¸°
      container.addEventListener('wheel', (e) => {
        e.preventDefault();
        
        const delta = e.deltaY * 0.05;
        bubbleState.cameraDistance += delta;
        bubbleState.cameraDistance = Math.max(0.1, Math.min(30, bubbleState.cameraDistance));
        
        if (bubbleState.cameraDistance > 12) {
          if (!bubbleState.isOutside) {
            bubbleState.isOutside = true;
            bubbleState.clickCount = 0; // ë°”ê¹¥ìœ¼ë¡œ ë‚˜ê°€ë©´ í´ë¦­ ì¹´ìš´í„° ë¦¬ì…‹
            // ì•ˆìª½ ì•ˆë‚´ ë¬¸êµ¬ ìˆ¨ê¸°ê³  ë°”ê¹¥ìª½ ì•ˆë‚´ ë¬¸êµ¬ í‘œì‹œ
            if (hintInside) hintInside.classList.remove('visible');
            if (hintOutside) {
              hintOutside.style.display = 'block';
              setTimeout(() => hintOutside.classList.add('visible'), 100);
            }
            if (newBubbleBtn) {
              newBubbleBtn.style.display = 'block';
            }
          }
        } else {
          bubbleState.isOutside = false;
          bubbleState.clickCount = 0; // ì•ˆìœ¼ë¡œ ë“¤ì–´ì˜¤ë©´ í´ë¦­ ì¹´ìš´í„° ë¦¬ì…‹
          // ë°”ê¹¥ìª½ ì•ˆë‚´ ë¬¸êµ¬ ìˆ¨ê¸°ê³  ì•ˆìª½ ì•ˆë‚´ ë¬¸êµ¬ í‘œì‹œ
          if (hintOutside) {
              hintOutside.classList.remove('visible');
              setTimeout(() => hintOutside.style.display = 'none', 500);
            }
          if (hintInside) hintInside.classList.add('visible');
          if (newBubbleBtn) {
            newBubbleBtn.style.display = 'none';
          }
        }
      });
      
      // ë°”ê¹¥ì—ì„œ êµ¬ë¥¼ 5ë²ˆ ì´ìƒ í´ë¦­í•˜ë©´ í„°ì§€ê¸°
      container.addEventListener('click', (e) => {
        if (!bubbleState.isOutside || bubbleState.isExploding) return;
        
        const now = Date.now();
        if (now - bubbleState.lastClickTime < 1000) {
          bubbleState.clickCount++;
        } else {
          bubbleState.clickCount = 1;
        }
        bubbleState.lastClickTime = now;
        
        // í´ë¦­ ì‹œ ë²„ë¸”ì´ ìš¸ë ê±°ë¦¬ëŠ” ëª¨ì…˜
        shakeIntensity = 0.3;
        
        if (bubbleState.clickCount >= 5) {
          explodeBubble(cards);
        }
      });
      
      // ë˜ ë‹¤ë¥¸ ë²„ë¸” ë§Œë“¤ê¸° ë²„íŠ¼
      if (newBubbleBtn) {
        newBubbleBtn.addEventListener('click', () => {
          // ì²« ë²ˆì§¸ ìŠ¤í…Œì´ì§€ë¡œ ëŒì•„ê°€ê¸°
          stages.bubble.classList.remove('active');
          stages.pile.classList.add('active');
          state.bubbleInited = false;
          state.isGridFull = false;
          state.likes = 0;
          state.selectedTopic = null;
          
          // í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ ëŒ€ì‹  ì´ˆê¸°í™”
          location.reload();
        });
      }
      
      function explodeBubble(cards) {
        if (bubbleState.isExploding) return; // ì´ë¯¸ í„°ì§€ê³  ìˆìœ¼ë©´ ë°˜ë³µ ë°©ì§€
        bubbleState.isExploding = true;
        
        // ì¹´ë“œë“¤ì„ Y ì¢Œí‘œ(ë†’ì´)ì— ë”°ë¼ ì •ë ¬í•˜ì—¬ ìœ— í–‰ë¶€í„° ë¬´ë„ˆì§€ê²Œ
        const sortedCards = cards.map((card, i) => ({
          card,
          y: card.position.y,
          index: i
        })).sort((a, b) => b.y - a.y); // ìœ„ì—ì„œ ì•„ë˜ë¡œ ì •ë ¬
        
        sortedCards.forEach((item, delayIndex) => {
          const card = item.card;
          const delay = delayIndex * 20; // ìœ— í–‰ë¶€í„° ìˆœì°¨ì ìœ¼ë¡œ ì‹œì‘
          
          setTimeout(() => {
            // ì¤‘ë ¥ ì ìš© - ì•„ë˜ë¡œ ë–¨ì–´ì§€ë„ë¡
            const gravity = -0.02; // ì•„ë˜ ë°©í–¥
            const horizontalSpread = (Math.random() - 0.5) * 0.1; // ìˆ˜í‰ í™•ì‚°
            const forwardSpread = (Math.random() - 0.5) * 0.1; // ì „ë°© í™•ì‚°
            
            card.userData.velocity = new THREE.Vector3(
              horizontalSpread,
              gravity, // ì•„ë˜ë¡œ ë–¨ì–´ì§
              forwardSpread
            );
            
            // ëœë¤ íšŒì „ ì†ë„ ì¶”ê°€
            card.userData.rotationSpeed = new THREE.Vector3(
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2,
              (Math.random() - 0.5) * 0.2
            );
            
            // ì¹´ë“œê°€ ë–¨ì–´ì§€ëŠ” ì†ë„ ì¦ê°€
            card.userData.gravity = gravity;
            card.userData.fallSpeed = 0;
          }, delay);
        });
      }
      
      function animate() {
        requestAnimationFrame(animate);
        
        // ì¹´ë©”ë¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        const targetZ = bubbleState.cameraDistance;
        camera.position.z += (targetZ - camera.position.z) * 0.1;
        
        // ë²„ë¸” ìš¸ë ê±°ë¦¬ëŠ” ëª¨ì…˜ (í´ë¦­ ì‹œ)
        if (shakeIntensity > 0 && !bubbleState.isExploding) {
          const shakeX = (Math.random() - 0.5) * shakeIntensity;
          const shakeY = (Math.random() - 0.5) * shakeIntensity;
          const shakeZ = (Math.random() - 0.5) * shakeIntensity;
          
          group.position.set(shakeX, shakeY, shakeZ);
          shakeIntensity *= 0.9; // ì ì  ê°ì†Œ
          
          if (shakeIntensity < 0.01) {
            shakeIntensity = 0;
            group.position.set(0, 0, 0);
          }
        }
        
        // ê·¸ë¦¬ë“œì—ì„œ êµ¬ë¡œ ì „í™˜ ì• ë‹ˆë©”ì´ì…˜
        cards.forEach(card => {
          if (card.userData.isTransitioning && !bubbleState.isExploding) {
            card.userData.transitionProgress += 0.02;
            if (card.userData.transitionProgress > 1) {
              card.userData.transitionProgress = 1;
              card.userData.isTransitioning = false;
            }
            
            const t = card.userData.transitionProgress;
            const easeT = t * t * (3 - 2 * t); // Smoothstep
            
            card.position.lerp(card.userData.targetPosition, easeT);
            
            // Look at center during transition
            const lookAt = new THREE.Vector3(0, 0, 0);
            card.lookAt(lookAt);
          }
        });
        
        // í­ë°œ ì• ë‹ˆë©”ì´ì…˜ - ë¹„ëˆ—ë°©ìš¸ í„°ì§€ë“¯ì´ (íˆ¬ëª…ë„ ë³€ê²½ ì—†ì´)
        if (bubbleState.isExploding) {
          cards.forEach(card => {
            if (card.userData.velocity) {
              // ì¤‘ë ¥ ì ìš© - ì•„ë˜ë¡œ ê°€ì†
              if (card.userData.gravity !== undefined) {
                card.userData.fallSpeed = (card.userData.fallSpeed || 0) + card.userData.gravity;
                card.userData.velocity.y = card.userData.fallSpeed;
              }
              
              card.position.add(card.userData.velocity);
              
              // ì¹´ë“œê°€ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±° (íˆ¬ëª…ë„ ë³€ê²½ ì—†ì´)
              const distance = Math.sqrt(
                card.position.x * card.position.x + 
                card.position.y * card.position.y + 
                card.position.z * card.position.z
              );
              
              if (distance > 50 || card.position.y < -30) {
                // ì¹´ë“œë¥¼ ì”¬ì—ì„œ ì œê±°
                group.remove(card);
                card.geometry.dispose();
                card.material.dispose();
              }
            }
            
            if (card.userData.rotationSpeed) {
              card.rotation.x += card.userData.rotationSpeed.x;
              card.rotation.y += card.userData.rotationSpeed.y;
              card.rotation.z += card.userData.rotationSpeed.z;
              
              // íšŒì „ ê°ì†
              card.userData.rotationSpeed.multiplyScalar(0.98);
            }
            
            // ìˆ˜í‰ ì†ë„ ê°ì†Œ
            if (card.userData.velocity) {
              card.userData.velocity.x *= 0.99;
              card.userData.velocity.z *= 0.99;
            }
          });
        }
        
        renderer.render(scene, camera);
      }
      animate();
      
      // Handle Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
    // --- Animated Gradient Background ---
    function initAnimatedGradient() {
      // ë„¤ ê°€ì§€ ìƒ‰ìƒ ì¡°í•©
      const colors = [
        { r: 255, g: 255, b: 255 }, // #FFFFFF
        { r: 255, g: 0, b: 191 },   // #FF00BF
        { r: 255, g: 0, b: 0 },     // #FF0000
        { r: 255, g: 55, b: 0 }     // #FF3700
      ];
      
      const opacity = 0.25; // ë°°ê²½ íˆ¬ëª…ë„ 25% (ë” íˆ¬ëª…í•˜ê²Œ)
      
      let time = 0;
      const speed = 0.005; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„ ì¦ê°€ (ë” ë¹ ë¥´ê³  ëª…í™•í•˜ê²Œ ì „í™˜)
      
      function lerpColor(color1, color2, t) {
        // ë” ëª…í™•í•œ ì „í™˜ì„ ìœ„í•´ easing í•¨ìˆ˜ ì ìš©
        const easedT = t * t * (3 - 2 * t); // smoothstep
        return {
          r: Math.round(color1.r + (color2.r - color1.r) * easedT),
          g: Math.round(color1.g + (color2.g - color1.g) * easedT),
          b: Math.round(color1.b + (color2.b - color1.b) * easedT)
        };
      }
      
      function updateGradient() {
        time += speed;
        
        // ìƒ‰ìƒ ì¸ë±ìŠ¤ ê³„ì‚° (ìˆœí™˜)
        const colorProgress = (time * colors.length) % colors.length;
        const colorIndex1 = Math.floor(colorProgress) % colors.length;
        const colorIndex2 = (colorIndex1 + 1) % colors.length;
        const colorIndex3 = (colorIndex1 + 2) % colors.length;
        const t = colorProgress - Math.floor(colorProgress);
        
        // ì¤‘ì‹¬ ìƒ‰ìƒ (í˜„ì¬ -> ë‹¤ìŒ)
        const centerColor1 = colors[colorIndex1];
        const centerColor2 = colors[colorIndex2];
        const centerColor = lerpColor(centerColor1, centerColor2, t);
        
        // ì¤‘ê°„ ìƒ‰ìƒ (ë‹¤ìŒ -> ê·¸ ë‹¤ìŒ)
        const midColor1 = colors[colorIndex2];
        const midColor2 = colors[colorIndex3];
        const midColor = lerpColor(midColor1, midColor2, t);
        
        // ì™¸ê³½ ìƒ‰ìƒ (ê·¸ ë‹¤ìŒ -> ê·¸ ë‹¤ìŒ ë‹¤ìŒ)
        const outerColor1 = colors[colorIndex3];
        const outerColor2 = colors[(colorIndex3 + 1) % colors.length];
        const outerColor = lerpColor(outerColor1, outerColor2, t);
        
        // ê°ë„ ë³€í™” (ì›í˜•ìœ¼ë¡œ ì¤‘ì‹¬ ìœ„ì¹˜ ë³€ê²½, ë” ë¹ ë¥´ê²Œ)
        const angle = time * 1.2; // ê°ë„ ë³€í™” ì†ë„ ì¦ê°€ (ë” ë¹ ë¥´ê²Œ)
        const centerX = 50 + Math.cos(angle) * 40; // ì¤‘ì‹¬ X ìœ„ì¹˜ (10% ~ 90%, ë” ë„“ê²Œ)
        const centerY = 50 + Math.sin(angle * 1.5) * 40; // ì¤‘ì‹¬ Y ìœ„ì¹˜ (ë¹„ëŒ€ì¹­ ì›€ì§ì„, ë” ë„“ê²Œ)
        
        // Radial ê·¸ë¼ë°ì´ì…˜ ìƒì„± (íˆ¬ëª…ë„ 35% ì ìš©, ê°ë„ ë³€í™”)
        const gradient = `radial-gradient(circle at ${centerX}% ${centerY}%, 
          rgba(${centerColor.r}, ${centerColor.g}, ${centerColor.b}, ${opacity}) 0%, 
          rgba(${midColor.r}, ${midColor.g}, ${midColor.b}, ${opacity}) 50%, 
          rgba(${outerColor.r}, ${outerColor.g}, ${outerColor.b}, ${opacity}) 100%)`;
        
        document.body.style.background = gradient;
        
        requestAnimationFrame(updateGradient);
      }
      
      updateGradient();
    }
    
    // Start
    initAnimatedGradient();
    initStartScreen();
  </script>
</body>
</html>